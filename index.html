<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <title>Coverflow Flipbook</title>
    <!-- Swiper CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.css" />
    <style>
        /* General body and HTML styles */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #111;
            touch-action: none;
        }

        /* Swiper container and its initial state */
        .swiper {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease-in;
        }

        /* Fades in the swiper once it's loaded */
        .swiper.swiper-loaded {
            opacity: 1;
        }

        /* Styles for each slide */
        .swiper-slide {
            width: auto;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Inner container for the image */
        .slide-inner {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        /* Image styles: responsive, rounded corners, and shadow */
        .slide-inner img {
            width: auto;
            height: auto;
            max-height: 90vh;
            max-width: 90vw;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s ease;
            cursor: pointer;
            touch-action: none;
        }

        /* CSS animation for the first page */
        .page1-breath {
            animation: breatheZoom 1.4s ease-out 1;
        }

        @keyframes breatheZoom {
            0% {
                transform: scale(1) brightness(0.3);
                opacity: 0;
            }
            60% {
                transform: scale(1.03) brightness(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1) brightness(1);
            }
        }

        /* Swiper navigation buttons styling */
        .swiper-button-next,
        .swiper-button-prev {
            color: white;
            width: 38px;
            height: 38px;
            background-color: transparent;
            border-radius: 50%;
        }

        .swiper-button-next::after,
        .swiper-button-prev::after {
            font-size: 22px;
        }

        /* Responsive adjustments for mobile devices */
        @media (max-width: 768px) {
            .slide-inner img {
                max-height: 80vh;
                max-width: 95vw;
            }
        }
    </style>
</head>
<body>

    <div class="swiper" id="swiperContainer" style="visibility: hidden;">
        <div class="swiper-wrapper" id="swiperWrapper"></div>
        <div class="swiper-button-next"></div>
        <div class="swiper-button-prev"></div>
    </div>

    <!-- Swiper JS library -->
    <script src="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.js"></script>
    <script>
        const wrapper = document.getElementById('swiperWrapper');
        const container = document.getElementById('swiperContainer');
        const MAX_PAGES = 60;
        let stopLoading = false;

        /**
         * Preloads images and appends slides to the Swiper wrapper.
         * This function handles potential errors if an image URL is not found.
         */
        async function preloadImagesAndAppendSlides() {
            for (let i = 1; i <= MAX_PAGES; i++) {
                if (stopLoading) break;
                const img = new Image();
                img.src = `pages/page${i}.jpg`;

                await new Promise((resolve) => {
                    img.onload = () => {
                        const slide = document.createElement('div');
                        slide.className = 'swiper-slide';
                        const imgClass = i === 1 ? 'page1-img' : '';
                        slide.innerHTML = `
                            <div class="slide-inner">
                                <img src="pages/page${i}.jpg" data-index="${i}" class="${imgClass}" />
                            </div>
                        `;
                        wrapper.appendChild(slide);
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load image: pages/page${i}.jpg`);
                        stopLoading = true;
                        resolve();
                    };
                });
            }
        }

        /**
         * Checks if the user is on an iOS device to adjust Swiper settings.
         * @returns {boolean} True if the device is iOS, false otherwise.
         */
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        let swiper;
        window.addEventListener('load', async () => {
            await preloadImagesAndAppendSlides();
            swiper = new Swiper('.swiper', {
                effect: 'coverflow',
                grabCursor: true,
                centeredSlides: true,
                slidesPerView: 'auto',
                slideToClickedSlide: true,
                watchSlidesProgress: true,
                initialSlide: 0,
                speed: isIOS() ? 600 : 400,
                touchRatio: 1,
                threshold: 10,
                coverflowEffect: {
                    rotate: isIOS() ? 5 : 8,
                    stretch: isIOS() ? 0 : -10,
                    depth: isIOS() ? 120 : 220,
                    modifier: 1,
                    slideShadows: true
                },
                navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                },
                keyboard: {
                    enabled: true,
                    onlyInViewport: true,
                },
                loop: false,
                on: {
                    init: function () {
                        this.slideTo(0, 0, false);
                        container.style.visibility = 'visible';
                        container.classList.add('swiper-loaded');
                        setTimeout(() => {
                            const page1 = document.querySelector('.page1-img');
                            if (page1) page1.classList.add('page1-breath');
                        }, 100);
                        setupZoomPan(this.slides[this.activeIndex].querySelector('img'));
                    },
                    slideChange: function () {
                        // Reset zoom and setup listeners for the new slide
                        setupZoomPan(this.slides[this.activeIndex].querySelector('img'));
                    }
                }
            });
        });

        // --- Zoom + Pan Logic ---
        let scale = 1;
        let activeImage = null;
        let isDragging = false;
        let startX = 0, startY = 0;
        let offsetX = 0, offsetY = 0;

        /**
         * Resets the zoom and pan state of the active image.
         */
        function resetZoom() {
            if (activeImage) {
                // Important: Reset the transform to an empty string to remove our custom styling
                // and allow Swiper to take over for the non-active slides.
                activeImage.style.transform = '';
            }
            scale = 1; offsetX = 0; offsetY = 0;
            isDragging = false;
            if (swiper) swiper.allowTouchMove = true;
        }

        /**
         * Updates the transform property of the active image for zoom and pan.
         */
        function updateTransform() {
            if (activeImage) {
                if (scale > 1) {
                    activeImage.style.transform = `scale(${scale}) translate(${offsetX / scale}px, ${offsetY / scale}px)`;
                } else {
                    activeImage.style.transform = '';
                }
            }
        }

        // --- Mouse-based event listeners for zoom and pan ---
        document.addEventListener('wheel', function (e) {
            if (e.ctrlKey) {
                e.preventDefault();
                activeImage = document.querySelector('.swiper-slide-active img');
                if (!activeImage) return;
                scale += e.deltaY * -0.002;
                scale = Math.min(Math.max(1, scale), 3);
                offsetX = 0;
                offsetY = 0;
                updateTransform();
            }
        }, { passive: false });

        document.addEventListener('dblclick', () => {
            activeImage = document.querySelector('.swiper-slide-active img');
            if (activeImage) {
                scale = scale === 1 ? 2 : 1;
                offsetX = 0;
                offsetY = 0;
                updateTransform();
            }
        });

        document.addEventListener('mousedown', function (e) {
            activeImage = document.querySelector('.swiper-slide-active img');
            if (!activeImage || scale === 1) return;
            isDragging = true;
            startX = e.clientX - offsetX;
            startY = e.clientY - offsetY;
            if (swiper) swiper.allowTouchMove = false;
        });

        document.addEventListener('mousemove', function (e) {
            if (!isDragging || scale === 1) return;
            offsetX = e.clientX - startX;
            offsetY = e.clientY - startY;
            updateTransform();
        });

        document.addEventListener('mouseup', function () {
            isDragging = false;
            if (scale === 1 && swiper) swiper.allowTouchMove = true;
        });

        // --- Touch-based event listeners for pinch-zoom and pan ---
        let initialDistance = null;
        let lastTapTime = 0;

        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchStart(e) {
            const now = new Date().getTime();
            if (e.touches.length === 2) {
                initialDistance = getDistance(e.touches);
                if (swiper) swiper.allowTouchMove = false;
            } else if (e.touches.length === 1) {
                const timeSinceLastTap = now - lastTapTime;
                lastTapTime = now;
                if (timeSinceLastTap < 300) { // Double tap logic
                    e.preventDefault();
                    e.stopPropagation();
                    scale = scale === 1 ? 2 : 1;
                    offsetX = 0;
                    offsetY = 0;
                    updateTransform();
                    if (swiper) swiper.allowTouchMove = (scale === 1);
                }
                if (scale > 1) { // Pan logic
                    isDragging = true;
                    startX = e.touches[0].clientX - offsetX;
                    startY = e.touches[0].clientY - offsetY;
                    e.stopPropagation();
                    if (swiper) swiper.allowTouchMove = false;
                }
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2 && initialDistance) { // Pinch-to-zoom
                e.preventDefault();
                e.stopPropagation();
                const currentDistance = getDistance(e.touches);
                const delta = (currentDistance - initialDistance) * 0.005;
                scale += delta;
                scale = Math.min(Math.max(1, scale), 3);
                offsetX = 0;
                offsetY = 0;
                updateTransform();
                initialDistance = currentDistance;
            }
            else if (e.touches.length === 1 && scale > 1 && isDragging) { // Pan
                e.preventDefault();
                e.stopPropagation();
                const touch = e.touches[0];
                offsetX = touch.clientX - startX;
                offsetY = touch.clientY - startY;
                updateTransform();
            }
        }

        function handleTouchEnd() {
            isDragging = false;
            initialDistance = null;
            if (scale === 1 && swiper) swiper.allowTouchMove = true;
        }
        
        /**
         * Sets up the touch and mouse event listeners for the given image element.
         * This function is crucial for preventing conflicts by only listening on the active slide.
         * @param {HTMLElement} imgElement The image element of the currently active slide.
         */
        function setupZoomPan(imgElement) {
            if (!imgElement) return;

            // Remove old listeners to prevent duplication
            if (activeImage) {
                activeImage.removeEventListener('touchstart', handleTouchStart);
                activeImage.removeEventListener('touchmove', handleTouchMove);
                activeImage.removeEventListener('touchend', handleTouchEnd);
            }

            // Set the new active image and reset its state
            activeImage = imgElement;
            resetZoom();

            // Add new listeners to the currently active image
            activeImage.addEventListener('touchstart', handleTouchStart, { passive: false });
            activeImage.addEventListener('touchmove', handleTouchMove, { passive: false });
            activeImage.addEventListener('touchend', handleTouchEnd);
        }

        // Recalculates the Swiper layout on orientation change
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (swiper) swiper.update();
            }, 500);
        });
    </script>
</body>
</html>
